#!/usr/bin/env ts-node

/**
 * Update version.ts with values from package.json
 * Modern TypeScript replacement for update-version.sh
 * Used in prebuild step to ensure version consistency
 */

import { readFileSync, writeFileSync } from "fs";
import { join, dirname } from "path";

interface PackageJson {
  name: string;
  version: string;
  [key: string]: unknown;
}

interface BuildInfo {
  version: string;
  buildTime: string;
  name: string;
}

class VersionUpdateError extends Error {
  constructor(message: string) {
    super(message);
    this.name = "VersionUpdateError";
  }
}

/**
 * Gets the project root directory
 */
function getProjectRoot(): string {
  const scriptDir = __dirname;
  return dirname(scriptDir);
}

/**
 * Reads and parses package.json
 */
function readPackageJson(projectRoot: string): PackageJson {
  const packageJsonPath = join(projectRoot, "package.json");

  try {
    const packageJsonContent = readFileSync(packageJsonPath, "utf8");
    const packageJson = JSON.parse(packageJsonContent) as PackageJson;

    return packageJson;
  } catch (error) {
    if (error instanceof Error && "code" in error && error.code === "ENOENT") {
      throw new VersionUpdateError(
        `package.json not found at ${packageJsonPath}`,
      );
    }
    throw new VersionUpdateError(
      `Failed to read or parse package.json: ${error instanceof Error ? error.message : String(error)}`,
    );
  }
}

/**
 * Validates package.json contents
 */
function validatePackageJson(packageJson: PackageJson): void {
  if (!packageJson.version || typeof packageJson.version !== "string") {
    throw new VersionUpdateError(
      "Package.json must contain a valid version string",
    );
  }

  if (!packageJson.name || typeof packageJson.name !== "string") {
    throw new VersionUpdateError(
      "Package.json must contain a valid name string",
    );
  }
}

/**
 * Generates build time in ISO format
 */
function generateBuildTime(): string {
  return new Date().toISOString();
}

/**
 * Generates the version.ts file content
 */
function generateVersionTsContent(buildInfo: BuildInfo): string {
  return `/**
 * Build version constants
 * This file is automatically generated during build process
 */
export const BUILD_INFO = {
  version: "${buildInfo.version}",
  buildTime: "${buildInfo.buildTime}",
  name: "${buildInfo.name}",
} as const;

export const APP_VERSION = BUILD_INFO.version;
export const BUILD_TIME = BUILD_INFO.buildTime;
export const APP_NAME = BUILD_INFO.name.includes("/")
  ? BUILD_INFO.name.split("/")[1]
  : BUILD_INFO.name;
`;
}

/**
 * Writes the version.ts file
 */
function writeVersionFile(projectRoot: string, content: string): void {
  const versionTsPath = join(projectRoot, "src", "version.ts");

  try {
    writeFileSync(versionTsPath, content, "utf8");
  } catch (error) {
    throw new VersionUpdateError(
      `Failed to write version.ts: ${error instanceof Error ? error.message : String(error)}`,
    );
  }
}

/**
 * Main function to update version.ts
 */
function updateVersion(): void {
  try {
    const projectRoot = getProjectRoot();
    const packageJson = readPackageJson(projectRoot);

    validatePackageJson(packageJson);

    const buildInfo: BuildInfo = {
      version: packageJson.version,
      buildTime: generateBuildTime(),
      name: packageJson.name,
    };

    const versionTsContent = generateVersionTsContent(buildInfo);
    writeVersionFile(projectRoot, versionTsContent);

    console.log(
      `✅ Updated version.ts with version: ${buildInfo.version}, name: ${buildInfo.name}`,
    );
  } catch (error) {
    console.error(
      `❌ Error: ${error instanceof Error ? error.message : String(error)}`,
    );
    process.exit(1);
  }
}

// Run the script if called directly
if (require.main === module) {
  updateVersion();
}

export { updateVersion, VersionUpdateError };
